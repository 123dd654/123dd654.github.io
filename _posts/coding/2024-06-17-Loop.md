---
layout: post
title: 자바스크립트 이벤트 루프 이해하기
date: 2024-06-17 10:00 +0900
description: 자바스크립트 이벤트 루프의 동작 원리와 성능 최적화 방법에 대해 알아봅니다.
image: https://github.com/123dd654/123dd654.github.io/assets/161431124/8c4e8c90-4d2f-4e6e-86aa-9df7ca98a3a3
category: 2024년도 공부내용
tags: JavaScript, Event Loop, Async
published: true
sitemap: true
---

## 자바스크립트 이벤트 루프 이해하기

자바스크립트는 싱글 스레드 언어로, 동시에 한 가지 작업만 수행할 수 있습니다. 그렇다면 어떻게 자바스크립트는 비동기 작업을 처리하고, 사용자 인터페이스를 부드럽게 유지할 수 있을까요? 그 비밀은 바로 이벤트 루프(Event Loop)에 있습니다. 이번 글에서는 이벤트 루프의 동작 원리와 이를 활용한 성능 최적화 방법에 대해 알아보겠습니다.

### 이벤트 루프란?

이벤트 루프는 자바스크립트의 실행 메커니즘 중 하나로, 콜 스택(Call Stack)과 태스크 큐(Task Queue)를 관리하며 비동기 작업을 처리합니다.

- 콜 스택(Call Stack): 현재 실행 중인 함수들이 쌓이는 스택 구조입니다.
- 태스크 큐(Task Queue): 나중에 실행될 비동기 작업들이 대기하는 큐입니다.

이벤트 루프는 콜 스택이 비어 있을 때마다 태스크 큐에서 대기 중인 작업을 콜 스택으로 이동시켜 실행합니다. 이를 통해 자바스크립트는 비동기 작업을 효율적으로 처리할 수 있습니다.

### 이벤트 루프의 동작 과정

1. 콜 스택이 비어 있는지 확인: 이벤트 루프는 콜 스택이 비어 있는지 계속해서 확인합니다.
2. 태스크 큐에서 작업 가져오기: 콜 스택이 비어 있으면, 태스크 큐에서 대기 중인 작업을 가져와 콜 스택에 추가합니다.
3. 작업 실행: 콜 스택에 추가된 작업을 실행합니다.
4. 반복: 이 과정을 반복하여 비동기 작업들을 처리합니다.

### 비동기 작업 예시

비동기 작업은 주로 다음과 같은 상황에서 사용됩니다:

- Ajax 요청: 서버와 비동기적으로 데이터를 주고받을 때 사용합니다.
- 이벤트 리스너: 사용자 입력(클릭, 키 입력 등)에 반응할 때 사용합니다.
- 타이머(setTimeout, setInterval): 특정 시간 후에 작업을 실행할 때 사용합니다.

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 1000);

console.log("End");

// 실행 결과:
// Start
// End
// Timeout (1초 후)
```

이 예제에서, `setTimeout` 함수는 비동기적으로 1초 후에 콜백 함수를 실행하도록 예약합니다. 따라서 `console.log('End')`가 먼저 실행되고, 1초 후에 `console.log('Timeout')`이 실행됩니다.

### 성능 최적화를 위한 팁

#### 1. 콜 스택을 비워두기

콜 스택이 비워져야 태스크 큐의 작업들이 실행될 수 있으므로, 긴 작업은 피하고 짧은 작업으로 나누어 처리합니다. 예를 들어, 긴 루프나 복잡한 계산은 적절한 비동기 처리나 분할 처리가 필요합니다.

```javascript
// 나쁜 예시: 긴 루프가 메인 스레드를 블록함
for (let i = 0; i < 1000000000; i++) {
  // 작업
}

// 좋은 예시: 긴 작업을 나누어 처리
function chunkedTask(iterations, chunkSize) {
  let i = 0;
  function doChunk() {
    const end = Math.min(i + chunkSize, iterations);
    for (; i < end; i++) {
      // 작업
    }
    if (i < iterations) {
      setTimeout(doChunk, 0); // 다음 청크를 큐에 추가
    }
  }
  doChunk();
}

chunkedTask(1000000000, 10000);
```

#### 2. 비동기 작업 활용

비동기 작업을 적절히 활용하여 메인 스레드의 작업을 분산시킵니다. 예를 들어, 네트워크 요청이나 파일 읽기와 같은 I/O 작업은 비동기적으로 처리하여 메인 스레드가 다른 작업을 계속할 수 있도록 합니다.

```javascript
// 비동기 함수 예시: fetch API를 사용한 네트워크 요청
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

#### 3. 이벤트 디버깅 도구 사용

브라우저 개발자 도구의 Performance 탭을 활용하여 이벤트 루프의 성능을 분석하고 최적화합니다. Performance 탭을 사용하면 함수 호출 스택, 이벤트 타이밍, 레이아웃 변화 등을 시각적으로 확인할 수 있습니다.

### 이벤트 루프 관련 추가 개념

#### 마이크로태스크 큐

마이크로태스크 큐(Microtask Queue)는 태스크 큐보다 우선순위가 높은 비동기 작업들을 처리하는 큐입니다. `Promise`의 후속 처리, `MutationObserver` 콜백 등이 마이크로태스크 큐에 추가됩니다.

```javascript
console.log("Start");

setTimeout(() => {
  console.log("setTimeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("End");

// 실행 결과:
// Start
// End
// Promise
// setTimeout
```

위 예제에서 `Promise`의 후속 처리가 `setTimeout` 콜백보다 먼저 실행되는 것을 볼 수 있습니다. 이는 마이크로태스크 큐의 작업이 태스크 큐의 작업보다 우선 실행되기 때문입니다.

#### 렌더링 단계

브라우저는 이벤트 루프 사이클 동안 렌더링 작업을 수행합니다. 렌더링 단계는 다음과 같은 작업을 포함합니다:

- 스타일 계산: CSS 규칙을 계산하여 각 요소에 적용합니다.
- 레이아웃: 요소의 위치와 크기를 계산합니다.
- 페인트: 요소를 화면에 그립니다.

렌더링 작업은 비동기 작업의 실행 후, 다음 이벤트 루프 사이클 전에 이루어집니다. 따라서, DOM 조작이나 스타일 변경 작업은 효율적으로 배치하여 렌더링 성능을 최적화해야 합니다.

### 결론

이벤트 루프는 자바스크립트가 비동기 작업을 처리하는 핵심 메커니즘입니다. 이를 잘 이해하고 활용하면 성능이 뛰어나고 반응성이 좋은 애플리케이션을 개발할 수 있습니다. 이번 글에서는 이벤트 루프의 기본 개념과 동작 원리, 성능 최적화를 위한 팁, 그리고 마이크로태스크 큐와 렌더링 단계와 같은 추가 개념에 대해 살펴보았습니다.

앞으로의 개발에서 이벤트 루프를 잘 활용해 보세요!
